
- plugin system
	- base.get_api doesn't work in thingy.odin -- this is because the global in there gets compiled into the plugin. Instead the kzg_plugin_loaded needs to be fed a struct that represents the plugin API API. On it you can register your plugin and fetch plugins. Fetching a plugin that is not yet registered will make it but give you a nil pointer that will later be filled out.
	- Do plugin compilation in two phases. First go over all plugins and output all the final APIs into the correct final folders. That way the plugins in flight can import other plugins before they are built. Then build all plugins and put DLLs in correct place.
	- Move types from `api_types.odin` to normal files and make them use some @api attribute. Make the whole type print into the API file
	- Rename `api_types.odin` to `api_imports.odin`... I think?
	- Try reloading a plugin when the DLL changes on disk.
		- Maybe we can reload the DLL that uses it too if the API struct changes (since the API struct becomes part of the import)

- introduce a separate rendering thread
	- we could do a job based system where command lists are created as jobs and then submitted
	- needs a renderer interface


- UI:
	- package?
